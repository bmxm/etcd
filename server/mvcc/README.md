
etcd v2版本后端存储实现是基于内存的，也没有提供事务相关的功能。
另外，它最大的问题就是EventHistroy表的长度限制，以及触发 watcher 时的缓冲区大小限制，这两点都可能会造成相关的事件丢失。
这些问题与其基于内存的实现方式有着莫大的关系，所以完全依赖其 watcher 机制来实现数据同步存在很大的风险。


v3版本的后端存储在一定程度上解决了上述问题，v3版本存储的具体实现在 mvcc 包中。在v3版本存储中，将 watcher 监听和持久化存储分开进行实现。

store分为两部分：
· 第一部分是backend store，在etcd v3的设计中，backend store可以使用多种不同的存储，默认使用的是BoltDB。BoltDB是一个单机的支持事务的键值对存储，etcd v3存储中提供的事务就是基于BoltDB的事务实现的。
· 第二部分是内存索引，核心实现是keyIndex。keyIndex是基于Google开源的一个btree实现的。

BoltDB是根据LMDB项目开发的一个的Go语言版的Key/Value存储，它的目标是为应用提供一个简单、高效、可靠的嵌入式数据库存储，而不是一个完整的数据库服务。
按照BoltDB官方文档的介绍，BoltDB之所以具有较高的性能，与其底层实现息息相关：
  · 为了让数据读取更加高效，BoltDB使用操作系统提供的 mmap 技术，避免I/O操作。mmap 是一种内存映射磁盘文件的技术，它会将一个文件映射到应用程序的地址空间中，实现文件的磁盘地址与进程中的一段虚拟地址一一映射。
        这样，应用程序无须再调用read、write等系统调用进行文件的读写（先将文件内容复制到内核空间，然后将数据从内核空间复制到用户空间），而是通过指针直接读写该段内存即可，底层的操作系统会自动将脏页写回到对应的文件中。
        mmap 技术减少了文件内容的复制次数，从而提高了文件读写的效率。这里不再深入介绍mmap的实现原理，感兴趣的读者可以参考相关文章进行学习。
  · 为了提高读操作的并发，使用写时复制技术（Copy On Write）。
  · 为了提高随机读操作的性能，内部使用B+树实现索引。
  · BoltDB使用Go语言开发，而且曾经被 Influx DB用做底层存储。